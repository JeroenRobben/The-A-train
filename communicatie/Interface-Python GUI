# Note: VPython, numpy and pySerial must be installed on you pc

from visual import *
from visual.graph import *
import wx
import serial

SERIAL_ON = True

RADIUS = 110.           # radius in cm
STRAIGHT = 250.         # straight track length in cm
TERMINAL_LENGTH = 120.  # length of the track between the switch and terminal in cm
TERMINAL_RICO = 0.5     # rico of the track between the switch and terminal in cm

FRAMERATE = 25              # frames per second
SpeedPWMToSpeed = 50./180.  # in cm/(s PWM)



class TheATrain:
    def __init__(self):

        if SERIAL_ON:
            self.ArduinoData = serial.Serial('com14', 9600)

        self.set_mainwindow()
        self.draw_track()

        self.FrameRate = FRAMERATE
        self.SpeedPWMToSpeed = SpeedPWMToSpeed

        self.SendStatusValue = 0
        self.SendSpeedValue = 128

    def mainloop(self):

        while True:
            rate(self.FrameRate)

            if SERIAL_ON and self.ArduinoData.inWaiting() > 0:
                self.read_serial_data()

            cmPerFrame = self.Train.Speed/self.FrameRate

            self.Train.PreviousLocationIndex = self.Train.LocationIndex
            self.Train.LocationIndex += self.Train.IndexDirection * cmPerFrame
            if self.TrainDuplicate.visible:
                self.TrainDuplicate.PreviousLocationIndex = self.TrainDuplicate.LocationIndex
                self.TrainDuplicate.LocationIndex += self.TrainDuplicate.IndexDirection * cmPerFrame

            # End of ellipse fix:
            if self.Train.Location == self.Ellipse and self.Train.LocationIndex >= len(self.Ellipse.x):
                self.Train.LocationIndex -= len(self.Ellipse.x)
            if self.Train.Location == self.Ellipse and self.Train.LocationIndex < 0:
                self.Train.LocationIndex += len(self.Ellipse.x)

            # End of left terminal fix:
            if self.Train.Location == self.LeftTerminal and self.Train.LocationIndex >= len(self.LeftTerminal.x):
                self.Train.LocationIndex = len(self.LeftTerminal.x) - 1

            # Start of left terminal fix:
            if self.Train.Location == self.LeftTerminal and self.Train.LocationIndex < 0:
                self.Train.Location = self.Ellipse
                self.Train.LocationIndex += self.SwitchLeft.Index

            # Left switch:
            if self.Train.Location == self.Ellipse and self.Train.IndexDirection == 1 \
                    and self.Train.PreviousLocationIndex <= self.SwitchLeft.Index < self.Train.LocationIndex \
                    and self.SwitchLeft.Status != 0:
                if self.SwitchLeft.Status == 2:
                    self.duplicate_train(location=self.Ellipse, locationIndex=self.Train.LocationIndex,
                                         previousLocationIndex=self.Train.PreviousLocationIndex,
                                         indexDirection=self.Train.IndexDirection)
                self.Train.Location = self.LeftTerminal
                self.Train.LocationIndex -= self.SwitchLeft.Index

            # End of right terminal fix:
            if self.Train.Location == self.RightTerminal and self.Train.LocationIndex >= len(self.RightTerminal.x):
                self.Train.LocationIndex = len(self.RightTerminal.x) - 1

            # Start of right terminal fix:
            if self.Train.Location == self.RightTerminal and self.Train.LocationIndex < 0:
                self.Train.Location = self.Ellipse
                self.Train.LocationIndex = self.SwitchRight.Index - self.Train.LocationIndex
                self.Train.IndexDirection = 1

            # Right Switch:
            if self.Train.Location == self.Ellipse and self.Train.IndexDirection == -1 \
                    and self.Train.PreviousLocationIndex >= self.SwitchRight.Index > self.Train.LocationIndex \
                    and self.SwitchRight.Status != 0:
                if self.SwitchRight.Status == 2:
                    self.duplicate_train(location=self.Ellipse, locationIndex=self.Train.LocationIndex,
                                         previousLocationIndex=self.Train.PreviousLocationIndex,
                                         indexDirection=self.Train.IndexDirection)
                self.Train.Location = self.RightTerminal
                self.Train.LocationIndex = self.SwitchRight.Index - self.Train.LocationIndex
                self.Train.IndexDirection = 1

            if self.Train.Location == self.Ellipse:
                xPos = self.Ellipse.x[int(self.Train.LocationIndex)]
                zPos = self.Ellipse.z[int(self.Train.LocationIndex)]
            elif self.Train.Location == self.LeftTerminal:
                xPos = self.LeftTerminal.x[int(self.Train.LocationIndex)]
                zPos = self.LeftTerminal.z[int(self.Train.LocationIndex)]
            elif self.Train.Location == self.RightTerminal:
                xPos = self.RightTerminal.x[int(self.Train.LocationIndex)]
                zPos = self.RightTerminal.z[int(self.Train.LocationIndex)]
            self.Train.pos = (xPos, 0, zPos)

            if self.TrainDuplicate.visible and self.TrainDuplicate.Location == self.Ellipse:
                xPos = self.Ellipse.x[int(self.TrainDuplicate.LocationIndex)]
                zPos = self.Ellipse.z[int(self.TrainDuplicate.LocationIndex)]
                self.TrainDuplicate.pos=(xPos, 0, zPos)



    def read_serial_data(self):

        TextLine = self.ArduinoData.readline()
        DataArray = TextLine.split(" , ")
        print "beacon: ", DataArray[0]
        print "status: ", DataArray[1]
        print "speed: ", DataArray[2]
        print "direction: ", DataArray[3]

        self.BeaconText.SetLabelText(text="Last beacon: " + str(DataArray[0]))
        if self.Beacons.ID[self.Train.LastBeaconID].Number != int(DataArray[0]):
            possibleCurrentBeaconIDs = list()
            possibleCurrentBeaconDistances = list()
            for ID in self.Train.NextBeaconID:
                if self.Beacons.ID[ID].Number == int(DataArray[0]):
                    possibleCurrentBeaconIDs.append(ID)
            trainToKeep = ""
            for ID2 in possibleCurrentBeaconIDs:
                if not self.Train.visible and self.Beacons.ID[ID2].Location == self.Train.Location:
                    distance = abs(self.Beacons.ID[ID2].Index - self.Train.LocationIndex)
                    possibleCurrentBeaconDistances.append(distance)
                elif self.TrainDuplicate.visible and self.Beacons.ID[ID2].Location == self.Train.Location:
                    distance = abs(self.Beacons.ID[ID2].Index - self.Train.LocationIndex)
                    possibleCurrentBeaconDistances.append(distance)
                    trainToKeep = self.Train
                elif self.TrainDuplicate.visible and self.Beacons.ID[ID2].Location == self.TrainDuplicate.Location:
                    distance = abs(self.Beacons.ID[ID2].Index - self.Train.LocationIndex)
                    possibleCurrentBeaconDistances.append(distance)
                    trainToKeep = self.TrainDuplicate
                else:
                    possibleCurrentBeaconDistances.append(float("inf"))
            if self.TrainDuplicate.visible and trainToKeep == self.Train:
                self.TrainDuplicate.visible = False
            elif self.TrainDuplicate.visible and trainToKeep == self.TrainDuplicate:
                self.Train.Location = self.TrainDuplicate.Location
                self.Train.LocationIndex = self.TrainDuplicate.LocationIndex
                self.Train.IndexDirection = self.TrainDuplicate.IndexDirection
                self.TrainDuplicate.visible = False
            closestBeaconDistance = float("inf")
            closestBeaconIndex = 0
            for index in range(0, len(possibleCurrentBeaconDistances)):
                if possibleCurrentBeaconDistances[index] < closestBeaconDistance:
                    closestBeaconDistance = possibleCurrentBeaconDistances[index]
                    closestBeaconIndex = index
            self.Train.PreviousLastBeaconID = self.Train.LastBeaconID
            self.Train.LastBeaconID = possibleCurrentBeaconIDs[closestBeaconIndex]
            self.Train.NextBeaconID = self.Beacons.ID[self.Train.LastBeaconID].SurroundingBeaconIDs
            self.Train.NextBeaconNumber = set()
            self.Train.LocationIndex = self.Beacons.ID[self.Train.LastBeaconID].Index
            for ID3 in self.Train.NextBeaconID:
                self.Train.NextBeaconNumber.add(self.Beacons.ID[ID3].Number)
            self.NextBeaconText.SetLabelText(text="Next beacon: " + str(self.Train.NextBeaconNumber))

        if DataArray[1] == 0:
            self.Train.Status = "Autonomous"
        elif DataArray[1] == 1:
            self.Train.Status = "Controlled"
        elif DataArray[1] == 2:
            self.Train.Status = "Emergency!"
        self.StatusText.SetLabelText(text="Status: " + self.Train.Status)

        SpeedPWM = int(DataArray[2])
        self.Train.Speed = SpeedPWM * SpeedPWMToSpeed
        self.SpeedText.SetLabelText(text="Speed: " + str(round(self.Train.Speed, 2)) + " cm/s")

        self.Train.PreviousSpeedDirection = self.Train.SpeedDirection
        self.Train.SpeedDirection = int(DataArray[3])
        if self.Train.PreviousSpeedDirection != self.Train.SpeedDirection:
            self.Train.IndexDirection *= -1
        if self.Train.SpeedDirection == 1:
            self.DirectionText.SetLabelText(text="Direction: Forward")
        elif self.Train.SpeedDirection == 0:
            self.DirectionText.SetLabelText(text="Direction: Backward")


    def duplicate_train(self, location, locationIndex, previousLocationIndex, indexDirection):
        self.TrainDuplicate.Location = location
        self.TrainDuplicate.LocationIndex = locationIndex
        self.TrainDuplicate.PreviousLocationIndex = previousLocationIndex
        self.TrainDuplicate.IndexDirection = indexDirection
        self.TrainDuplicate.Speed = self.Train.Speed
        self.TrainDuplicate.SpeedDirection = self.Train.SpeedDirection
        self.TrainDuplicate.PreviousSpeedDirection = self.Train.PreviousSpeedDirection
        self.TrainDuplicate.Status = self.Train.Status
        self.TrainDuplicate.visible = True


    def set_mainwindow(self):

        self.MainWindow = window(width=1000, height=900, title="The A Train",
                                 style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))

        self.Scene = display(title='The A Train', window=self.MainWindow)
        self.Scene.width = 1000
        self.Scene.height = 700

        self.Panel = self.MainWindow.panel

        self.Font1 = wx.Font(18, wx.DEFAULT, wx.NORMAL, wx.NORMAL)

        self.StatusText = wx.StaticText(self.Panel, pos=(10, 710), label="Status: ", size=(400, 25),
                                        style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.StatusText.SetFont(self.Font1)
        self.SpeedText = wx.StaticText(self.Panel, pos=(10, 740), label="Speed: ", size=(400, 25),
                                       style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.SpeedText.SetFont(self.Font1)
        self.DirectionText = wx.StaticText(self.Panel, pos=(10, 770), label="Direction: ", size=(400, 25),
                                           style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.DirectionText.SetFont(self.Font1)
        self.BeaconText = wx.StaticText(self.Panel, pos=(10, 800), label="Last beacon: ", size=(400, 25),
                                        style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.BeaconText.SetFont(self.Font1)
        self.NextBeaconText = wx.StaticText(self.Panel, pos=(10, 830), label="Next beacon: ", size=(400, 25),
                                            style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.NextBeaconText.SetFont(self.Font1)

        self.SendText = wx.StaticText(self.Panel, pos=(480, 710), label="Send status and speed to Train A:",
                                      size=(400, 28), style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.SendText.SetFont(self.Font1)
        self.StatusBox = wx.RadioBox(self.Panel, pos=(480, 740), size=(130, 85),
                                     choices=["Autonomous", "Controlled", "Emergency"], style=wx.RA_SPECIFY_ROWS)
        self.StatusBox.Bind(wx.EVT_RADIOBOX, self.toggleStatus)
        self.SpeedSlider = wx.Slider(self.Panel, pos=(670, 780), size=(270, 20), minValue=0, maxValue=255,
                                     style=wx.SL_LABELS)
        self.SpeedSlider.Bind(wx.EVT_SCROLL, self.setSpeed)
        self.SpeedSliderMin = wx.StaticText(self.Panel, pos=(647, 765), label="Full Backward",
                                            style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.SpeedSliderMax = wx.StaticText(self.Panel, pos=(895, 765), label="Full Forward",
                                            style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
        self.SendButton = wx.Button(self.Panel, label="Send", pos=(480, 834))
        self.SendButton.Bind(wx.EVT_BUTTON, self.sendCommand)

    def draw_track(self):

        self.Radius = RADIUS
        self.Straight = STRAIGHT
        self.TerminalLength = TERMINAL_LENGTH
        self.TerminalRico = TERMINAL_RICO

        self.Floor = box(pos=(0, -5, -30), length=500, width=350, height=10, color=color.white)

        q1 = arange(0, pi*RADIUS/2, 1.)
        q2 = q1 + pi*RADIUS/2
        q3 = q1 + pi*RADIUS
        q4 = q1 + pi*RADIUS*3/2

        d1 = arange(0, TERMINAL_LENGTH, 1.)
        d2 = -d1

        ArrayXRightLowerCurve = RADIUS*cos(q1/RADIUS) + STRAIGHT/2
        ArrayZRightLowerCurve = RADIUS*sin(q1/RADIUS) - 50
        ArrayXLeftLowerCurve = RADIUS*cos(q2/RADIUS) - STRAIGHT/2
        ArrayZLeftLowerCurve = RADIUS*sin(q2/RADIUS) - 50
        ArrayXLeftUpperCurve = RADIUS*cos(q3/RADIUS) - STRAIGHT/2
        ArrayZLeftUpperCurve = RADIUS*sin(q3/RADIUS) - 50
        ArrayXRightUpperCurve = RADIUS*cos(q4/RADIUS) + STRAIGHT/2
        ArrayZRightUpperCurve = RADIUS*sin(q4/RADIUS) - 50

        ArrayXUpperStraight = arange(-STRAIGHT/2, STRAIGHT/2, 1.)
        ArrayZUpperStraight = zeros(len(ArrayXUpperStraight))-RADIUS - 50
        ArrayXLowerStraight = -ArrayXUpperStraight
        ArrayZLowerStraight = zeros(len(ArrayXLowerStraight))+RADIUS - 50

        ArrayXRightTerminal = d1/(sqrt(1.+TERMINAL_RICO**2)) + STRAIGHT/2
        ArrayZRightTerminal = TERMINAL_RICO*d1/(sqrt(1.+TERMINAL_RICO**2)) + RADIUS - 50

        ArrayXLeftTerminal = -d1/(sqrt(1.+TERMINAL_RICO**2)) - STRAIGHT/2
        ArrayZLeftTerminal = -TERMINAL_RICO*(-d1/(sqrt(1.+TERMINAL_RICO**2))) + RADIUS - 50

        ArrayXCurve = append(ArrayXRightLowerCurve, ArrayXLowerStraight)
        ArrayXCurve = append(ArrayXCurve, ArrayXLeftLowerCurve)
        ArrayXCurve = append(ArrayXCurve, ArrayXLeftUpperCurve)
        ArrayXCurve = append(ArrayXCurve, ArrayXUpperStraight)
        ArrayXCurve = append(ArrayXCurve, ArrayXRightUpperCurve)

        ArrayZCurve = append(ArrayZRightLowerCurve, ArrayZLowerStraight)
        ArrayZCurve = append(ArrayZCurve, ArrayZLeftLowerCurve)
        ArrayZCurve = append(ArrayZCurve, ArrayZLeftUpperCurve)
        ArrayZCurve = append(ArrayZCurve, ArrayZUpperStraight)
        ArrayZCurve = append(ArrayZCurve, ArrayZRightUpperCurve)

        self.Ellipse = curve(x=ArrayXCurve, y=0, z=ArrayZCurve, color=color.red, radius=1.)
        self.Ellipse.Name = "Ellipse"
        self.RightTerminal = curve(x=ArrayXRightTerminal, y=0, z=ArrayZRightTerminal, color=color.red, radius=1.)
        self.RightTerminal.Name = "RightTerminal"
        self.LeftTerminal = curve(x=ArrayXLeftTerminal, y=0, z=ArrayZLeftTerminal, color=color.red, radius=1.)
        self.LeftTerminal.Name = "LeftTerminal"

        self.Origin = sphere(radius=2., color=color.blue, pos=(0, 0, 0))

        self.SwitchLeft = sphere(radius=1.5, color=color.black, pos=(-STRAIGHT/2, 0, RADIUS-50))
        self.SwitchLeft.Index = int(where(ArrayXCurve == -STRAIGHT/2)[0][0])
        self.SwitchRight = sphere(radius=1.5, color=color.black, pos=(STRAIGHT/2, 0, RADIUS-50))
        self.SwitchRight.Index = int(where(ArrayXCurve == STRAIGHT/2)[0][0])
        self.SwitchLeft.Status = 2       # 0=off, 1=on, 2=unknown
        self.SwitchRight.Status = 2      # 0=off, 1=on, 2=unknown

        # beacon types: 0=straight, 1=terminal, 2=terminalInternational, 3=turn, 4=switch
        #               5=turn&switch, 6=terminalArrival&switch, 7=terminalArrival (8=terminalDeparture)
        #               9=terminalArrival&turn

        self.Beacons = beacons(self.Ellipse, self.LeftTerminal, self.RightTerminal)
        self.Beacons.add_beacon(self.Ellipse, "b0", 0, 0, 0, {"b1", "b11"}, visible=False)
        self.Beacons.add_beacon(self.Ellipse, "b1", 4, 5, self.SwitchRight.Index - 50, {"b2", "b11"})
        self.Beacons.add_beacon(self.Ellipse, "b2", 9, 4, self.SwitchRight.Index + 50, {"b5", "b1", "b3"})
        self.Beacons.add_beacon(self.RightTerminal, "b3", 6, 6, 50, {"b4", "b2"})
        self.Beacons.add_beacon(self.RightTerminal, "b4", 8, 1, len(self.RightTerminal.x)-1, {"b3"})
        self.Beacons.add_beacon(self.Ellipse, "b5", 5, 4, self.SwitchLeft.Index - 50, {"b6", "b7", "b2"})
        self.Beacons.add_beacon(self.Ellipse, "b6", 3, 5, self.SwitchLeft.Index + 50, {"b9", "b5"})
        self.Beacons.add_beacon(self.LeftTerminal, "b7", 6, 6, 50, {"b8", "b5"})
        self.Beacons.add_beacon(self.LeftTerminal, "b8", 7, 1, len(self.LeftTerminal.x)-1, {"b7"})
        for index in arange(len(self.Ellipse.z)/2, len(self.Ellipse.z)):
            if self.Ellipse.z[index] == -self.Radius - 50:
                test = index
                break
        self.Beacons.add_beacon(self.Ellipse, "b9", 2, 9, test + 50, {"b6", "b10"})
        self.Beacons.add_beacon(self.Ellipse, "b10", 1, 2, test + self.Straight/2, {"b9", "b11"})
        self.Beacons.add_beacon(self.Ellipse, "b11", 2, 9, test + self.Straight - 50, {"b10", "b1"})

        self.Train = train(location=self.Ellipse)
        self.TrainDuplicate = train(location=self.Ellipse, visible=False)

    def toggleStatus(self, evt):
        self.SendStatusValue = self.StatusBox.GetSelection()

    def setSpeed(self, evt):
        self.SendSpeedValue = self.SpeedSlider.GetValue()

    def sendCommand(self, evt):
        message = str(self.SendSpeedValue) + str(self.SendStatusValue)
        while len(message) != 4:
            message = "0" + message
        print message
        if SERIAL_ON:
            self.ArduinoData.write(message)


class train(sphere):
    def __init__(self, location, radius=6., color=color.green, pos=(0, 0, 0), visible=True):
        sphere.__init__(self, radius=radius, color=color, pos=pos, visible=visible)
        self.IndexDirection = 1             # 1=clockwise,  -1=counterclockwise
        self.Speed = 40.                    # in cm/s
        self.SpeedDirection = 1             # 1=forward
        self.PreviousSpeedDirection = self.SpeedDirection
        self.Location = location
        self.LocationIndex = 0
        self.PreviousLocationIndex = 0
        self.Status = "Autonomous"
        self.LastBeaconID = "b0"
        self.PreviousLastBeaconID = "b0"
        self.NextBeaconID = ["b1", ]
        self.NextBeaconNumber = {4, }
        self.closestBeaconIndex = 0


class beacons:
    def __init__(self, ellipseTrack, leftTerminalTrack, rightTerminalTrack):
        self.ID = dict()
        self.Ellipse = ellipseTrack
        self.LeftTerminal = leftTerminalTrack
        self.RightTerminal = rightTerminalTrack

    def add_beacon(self, track, ID, number, type, index, surroundingBeaconIDs=set([]), visible=True):
        self.ID[ID] = beacon(track, ID, number, type, index, surroundingBeaconIDs, visible)


class beacon(sphere):
    def __init__(self, location, ID, number, type, index, surroundingBeaconIDs=set([]), visible=True):
        self.Location = location
        self.ID = ID
        self.Number = number
        self.Type = type
        self.Index = index
        self.SurroundingBeaconIDs = surroundingBeaconIDs
        self.SurroundingBeaconIDs.add(self.ID)
        if self.Location.Name == "Ellipse":
            sphere.__init__(self, radius=3., color=color.blue, pos=(self.Location.x[index], 0, self.Location.z[index]),
                            visible=visible)
        elif self.Location.Name == "RightTerminal":
            sphere.__init__(self, radius=3., color=color.blue,
                            pos=(self.Location.x[int(index)], 0, self.Location.z[int(index)]), visible=visible)
        elif self.Location.Name == "LeftTerminal":
            sphere.__init__(self, radius=3., color=color.blue,
                            pos=(self.Location.x[int(index)], 0, self.Location.z[int(index)]), visible=visible)
        else:
            print "Beacon: false location!"
        self.Label = label(pos=(self.pos[0], 25, self.pos[2]), text=str(number), box=False, visible=visible)


print "Starting TheATrain..."
theATrain = TheATrain()
theATrain.mainloop()
print "Finished"
print "Jef was here :DDDDDD"
