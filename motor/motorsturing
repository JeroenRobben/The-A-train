#include <Wire.h>
//#include "P&O3.h" //comment for development in arduino IDE

/*
MMMMMMMM               MMMMMMMM     OOOOOOOOO     TTTTTTTTTTTTTTTTTTTTTTT     OOOOOOOOO     RRRRRRRRRRRRRRRRR
M:::::::M             M:::::::M   OO:::::::::OO   T:::::::::::::::::::::T   OO:::::::::OO   R::::::::::::::::R
M::::::::M           M::::::::M OO:::::::::::::OO T:::::::::::::::::::::T OO:::::::::::::OO R::::::RRRRRR:::::R
M:::::::::M         M:::::::::MO:::::::OOO:::::::OT:::::TT:::::::TT:::::TO:::::::OOO:::::::ORR:::::R     R:::::R
M::::::::::M       M::::::::::MO::::::O   O::::::OTTTTTT  T:::::T  TTTTTTO::::::O   O::::::O  R::::R     R:::::R
M:::::::::::M     M:::::::::::MO:::::O     O:::::O        T:::::T        O:::::O     O:::::O  R::::R     R:::::R
M:::::::M::::M   M::::M:::::::MO:::::O     O:::::O        T:::::T        O:::::O     O:::::O  R::::RRRRRR:::::R
M::::::M M::::M M::::M M::::::MO:::::O     O:::::O        T:::::T        O:::::O     O:::::O  R:::::::::::::RR
M::::::M  M::::M::::M  M::::::MO:::::O     O:::::O        T:::::T        O:::::O     O:::::O  R::::RRRRRR:::::R
M::::::M   M:::::::M   M::::::MO:::::O     O:::::O        T:::::T        O:::::O     O:::::O  R::::R     R:::::R
M::::::M    M:::::M    M::::::MO:::::O     O:::::O        T:::::T        O:::::O     O:::::O  R::::R     R:::::R
M::::::M     MMMMM     M::::::MO::::::O   O::::::O        T:::::T        O::::::O   O::::::O  R::::R     R:::::R
M::::::M               M::::::MO:::::::OOO:::::::O      TT:::::::TT      O:::::::OOO:::::::ORR:::::R     R:::::R
M::::::M               M::::::M OO:::::::::::::OO       T:::::::::T       OO:::::::::::::OO R::::::R     R:::::R
M::::::M               M::::::M   OO:::::::::OO         T:::::::::T         OO:::::::::OO   R::::::R     R:::::R
MMMMMMMM               MMMMMMMM     OOOOOOOOO           TTTTTTTTTTT           OOOOOOOOO     RRRRRRRR     RRRRRRR
*/



 //******Pin allocation********

 //Sensors
 const byte PIN_SPEED = A3; //
 const byte PIN_COLLISION = A4;

 //Motor
 const byte PIN_MOTOR_A = 9; //Forward engine
 const byte PIN_MOTOR_V = 5; //Backward engine

 //I2C Communication
 //COMM master sender - MOTOR slave receiver
 const byte I2C_ADDRESS = 2; //

 //Emergency interrupts
 const byte PIN_EM_OUT = 0;
 const byte PIN_EM_IN = 7;

 //LCD
 const byte PIN_LCD = 1;

//Unused Pins, will be flagged as INPUT
 const byte UNUSED_PINS[] = {A0, A1, A2, A5, 4, 6, 8, 10, 11, 12, 13};
 const byte AMOUNT_UNUSED_PINS = 11; //needed to loop through the above array

 //******Global variables********

  // COMMUNICATION - Received by COMM
  byte terminal = 0; // 0 = No Terminal, 1 = International Terminal, 2 = National Terminal
  
  //int SNEL_COMM_TO_SENS[] = {0,100,200};


  // ENGINE AND SPEED CONTROL
  byte direction = 2;   // 0 = backward, 1 = forward 2 = stand still - received by COMM
  volatile int speed_COMM_raw = 0;  /// Speed wanted by COMM, can be changed by interrupt 0 - 255
  int speed_COMM_sens = 0; //speed sensor value to be approached, calculated from speed_COMM_raw
  byte speed_pwm = 0; //speed directly written to engine - PWM - 0-255

  // SENSORS

  //Speed
  int snelheid_raw = 0; // measured value of speed sensor 0-1023

  //Collision
  int collision_raw = 0; // measured value of collision sensor 0-1023
  bool collision_front = false;
  bool collision_back = false;


  /*
  measured value between 1023 - BOTS_REF[0] 	   => none of the sensors detecting object
  measured value between BOTS_REF[0] - BOTS_REF[1] => only front sensor detects object
  measured value between BOTS_REF[1] - BOTS_REF[2] => only back sensor detects object
  measured value between BOTS_REF[2] - 0		   => front and back sensor detecting object
  */

  const int BOTS_REF[] = {1000, 400, 220};

  // OTHERS
  byte emergency_local = 0; //Local emergency level
  volatile bool emergency_COMM = false; //COMM emergency level

  /*
  float OMTREK_WIEL = 0.115;
  float MAX_RPM = 250; //// Aan te passen na meting !!!!!!!!!!! ////
  float MAX_PWM = 255;
  float MAX_MPS = (0.115 * (MAX_RPM / 60));
  float MAX_SPEED = 255;
  //float gewenste_snelheid_mps = 0;  // in mps
  //float snelheid_mps = 0; //ogenblikkelijke snelheid mps
  //float snelheid_rpm = 0; //ogenblikkelijk toerental
  */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// HELPER FUNCTIONS////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////



/// SENSORS

void update_sensors(){


  // Speed sensor
  snelheid_raw = analogRead(PIN_SPEED);

  //snelheid_rpm = (snelheid_raw * MAX_RPM) / 1023 ;
  //snelheid_mps = OMTREK_WIEL * (snelheid_rpm / 60) ;


  // Collision sensors
  collision_raw = analogRead(PIN_COLLISION);

  //Loop through array BOTS_REF_RAW until corresponding value range is found
  bool found = false;

  byte i = 0;
  while((not found) && (i <= 2)){
    if (collision_raw >= BOTS_REF[i]){
      found = true;
    }
    else{
    i++;
    }
  }

  switch(i){
	  case 0:
		collision_front = false;
		collision_back = false;
		break;

	  case 1:
		collision_front = true;
		collision_back = false;
		break;

	  case 2:
		collision_front = false;
		collision_back = true;
		break;

	  default:
		collision_front = true;
		collision_back = true;
		break;

  }
}


// ENGINE CONTROL AND SPEED CALCULATION

//Send desired speed to engines
void speed_send(bool dont_brake = true){


  if(dont_brake){ //speed_send(false) == brake

    if (direction == 0) {//	backward
        digitalWrite(PIN_MOTOR_A, LOW);
        analogWrite(PIN_MOTOR_V, speed_pwm);
    }
    else if (direction == 1){ //forward
    	digitalWrite(PIN_MOTOR_V, LOW);
    	analogWrite(PIN_MOTOR_A, speed_pwm);
    }
  }

  else{ //brake
    digitalWrite(PIN_MOTOR_V, HIGH);
    digitalWrite(PIN_MOTOR_A, HIGH);
  }
}

//Calculate desired speed written to engines
void speed_calc() {

  if (speed_COMM_sens == 0){ //brake
    speed_send(false);
  }

  else if ((speed_COMM_sens > snelheid_raw) && speed_pwm >= 0)
  {
    speed_pwm--;
  }

  else if ((speed_COMM_sens < snelheid_raw) && speed_pwm <= 255)
  {
    speed_pwm++;
  }
}


// EMERGENCY

void emergency_local_check(){
	//Local emergency status is divided in 6 levels 

	//0: none of the sensors detecting object
	//1: train driving BACKWARD and only FRONT sensor detects object
	//2: train driving FORWARD and only BACK sensor detects object

	//3: train driving FORWARD and only FRONT sensor detects object
	//4: train driving BACKWARD and only BACK sensor detects object
	//5: both sensors detecting object

	//1,2,3,4,5 = emergency line to COMM will be set to HIGH
	//ONLY 3,4,5 = train will brake immediately

  if ((collision_front == false) && (collision_back == false)){// 0
    emergency_local = 0;
    digitalWrite(PIN_EM_OUT, LOW);
    }
  else if ((collision_front == true) && (collision_back == false) && (direction == 0)){ // 1
    emergency_local = 1;
    digitalWrite(PIN_EM_OUT, LOW);
    }

  else if ((collision_front == false) && (collision_back == true) && (direction == 1)){ // 2
    emergency_local = 2;
    digitalWrite(PIN_EM_OUT, LOW);
    }

  else if ((collision_front == true) && (collision_back == false)){ // 3
    emergency_local = 3;
    speed_send(false); //brake
    digitalWrite(PIN_EM_OUT, HIGH);
  }
  else if ((collision_front == false) && (collision_back == true)){ // 4
    emergency_local = 4;
    speed_send(false); //brake
    digitalWrite(PIN_EM_OUT, HIGH);
  }
  else if ((collision_front == true) && (collision_back == true)){ // 5
    emergency_local = 5;
    speed_send(false); //brake
    digitalWrite(PIN_EM_OUT, HIGH);
  }

}



// LCD
void setBacklight(byte brightness)
{
  Serial.write(0x80);  // send the backlight COMMand
  Serial.write(brightness);  // send the brightness value
}

void clearDisplay()
{
  Serial.write(0xFE);  // send the special COMMand
  Serial.write(0x01);  // send the clear screen COMMand
}

void setSerialCursor(byte cursor_position)
{
  Serial.write(0xFE);  // send the special COMMand
  Serial.write(0x80);  // send the set cursor COMMand
  Serial.write(cursor_position);  // send the cursor position
}

void update_lcd(){
  clearDisplay();
  Serial.print("SPEED ");
  Serial.print(speed_COMM_raw);
  setSerialCursor(10);
  Serial.write("m/s");
  setSerialCursor(16);
  Serial.print(emergency_COMM);
  Serial.print(" ");
  Serial.print(emergency_local);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// I2C & INTERRUPT FUNCTIONS///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

//RECEIVE I2C MESSAGE
void i2c_receive(int bytes_received){

   if (Wire.available() == 3) {
     direction = Wire.read();
     speed_COMM_raw = Wire.read();
     terminal = Wire.read();
   }
   else if (Wire.available() == 2) {
     direction = Wire.read();
     speed_COMM_raw = Wire.read();
   }
   if (speed_COMM_raw == 0){
     direction = 2;
   }
   speed_COMM_sens = SNEL_COMM_TO_SENS[speed_COMM_raw];
 }


//EMERGENCY INTERRUPT FROM COMM
void emergency_COMM_isr()
{
    digitalWrite(PIN_MOTOR_V, HIGH); //brake
    digitalWrite(PIN_MOTOR_A, HIGH);
    emergency_COMM = true;
	speed_COMM_raw = 0;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// MAIN SETUP /////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


void setup() {
  // Input/output behavior

  pinMode(PIN_SPEED, INPUT);
  pinMode(PIN_COLLISION, INPUT);

  pinMode(PIN_EM_OUT, OUTPUT);
  pinMode(PIN_EM_IN, INPUT);

  pinMode(PIN_MOTOR_V, OUTPUT);
  pinMode(PIN_MOTOR_A, OUTPUT);

  digitalWrite(PIN_MOTOR_V, LOW); //make sure engines are off
  digitalWrite(PIN_MOTOR_A, LOW);

  for (byte i = 0; i < AMOUNT_UNUSED_PINS; i++) {//flag unused pins as input
	  pinMode(UNUSED_PINS[i], INPUT);
  }

  // I2C Communication
  Wire.begin(I2C_ADDRESS);      // join i2c bus with address #2
  Wire.onReceive(i2c_receive); // read message from COMM

  // Attach emergencyergency interrupt
  attachInterrupt(digitalPinToInterrupt(PIN_EM_IN), emergency_COMM_isr, RISING); //emergency message from COMM

  Serial.begin(1200); //Communication with LCD

  delay(2000); //Boot time

  setBacklight(255); //LCD on
  clearDisplay();

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// MAIN LOOP //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

void loop() {

  update_sensors();
  emergency_local_check();

  if ((emergency_local <= 2) && (emergency_COMM = false)){
	  speed_pwm = speed_COMM_raw; //testing purposes
	  //speed_calc();
	  speed_send();
  }

  //update_lcd();
  delay(10);

	  while((emergency_COMM == true) || (digitalRead(PIN_EM_IN) == HIGH)){ //stay in loop while COMM is in emergency mode
		
		speed_send(false); //brake
	    emergency_COMM = false; //interrupt has been noticed
	    
	    //keep local emergency levels up to date
	    update_sensors(); 
	    emergency_local_check();
	  }

}
